module corpse_soil_carbon

! !Don't use external model stuff if compiling standalone version
! #ifndef STANDALONE_SOIL_CARBON
!
!
! use constants_mod, only : pi
! use land_constants_mod, only : Rugas, seconds_per_year
! use fms_mod, only: check_nml_error, file_exist, write_version_number, close_file, &
!             error_mesg,FATAL, NOTE
! use vegn_data_mod, only: K1,K2
! use land_numerics_mod,only: tridiag
!
! #ifdef INTERNAL_FILE_NML
! use mpp_mod, only: input_nml_file
! #else
! use fms_mod, only: open_namelist_file
! #endif
! #endif


!End of external model stuff

implicit none

private


! ==== public interfaces =====================================================
public :: soil_carbon_pool
public :: soilMaxCohorts

public :: update_pool
public :: add_litter
public :: add_litter2
public :: add_carbon_to_cohorts
public :: add_carbon_to_rhizosphere
public :: combine_pools
public :: poolTotalCarbon
public :: init_soil_carbon
public :: read_soil_carbon_namelist
public :: remove_carbon_fraction_from_pool
public :: cull_cohorts
public :: transfer_pool_fraction
! #ifndef STANDALONE_SOIL_CARBON
! public :: get_pool_data_accessors
! #endif
! =====end of public interfaces ==============================================


! ==== module constants ======================================================
integer,parameter::nspecies=3  !Carbon chemical species (Cellulose, lignin, microbial products)
integer,parameter::LABILE=1
integer,parameter::RECALCTRNT=2
integer,parameter::DEADMICRB=3
! character(len=*), parameter   :: &
!      version     = '$Id: soil_carbon.F90,v 1.1.2.11.2.5.2.9.2.2 2015/06/09 01:35:03 Benjamin.Sulman Exp $', &
!      tagname     = '$Name: ncc_rhizosphere_paper_bns $', &
!      module_name = 'corpse_soil_carbon'

! #ifdef STANDALONE_SOIL_CARBON
real,parameter::pi=3.141592
real,parameter::Rugas=8.314472
integer,parameter::FATAL=0,NOTE=1
real,parameter :: seconds_per_year=86400.0*365.0
! #endif

! ==== types =================================================================

!Individual litter cohort with its own carbon pools
type litterCohort
    !Carbon pools
    real,dimension(nspecies)::litterC  !Carbon substrate. Relative amounts of C species are important for resp rate
    real,dimension(nspecies)::protectedC !Aggregate and mineral complex C
    real::livingMicrobeC               !Current carbon mass of live microbes
    real::CO2                          !Cumulative CO2 generated by decomposition
    real::Rtot                         !Cumulative decomposition (includes double counting through microbial products)
    !Original C
    real::originalLitterC              !Keep track for carbon balance check
end type litterCohort


!Pool type, can hold multiple individual litter/carbon cohorts
type soil_carbon_pool
    integer::max_cohorts    !Maximum number of cohorts, allows different pools to have different maximum heterogeneity
    real::protection_rate   !Pool-specific rate that carbon is transferred to protected pool (aggregate and chemical protection)
    real::Qmax              !Pool DOC sorption capacity (See Mayes et al 2012)
    type(litterCohort),allocatable::litterCohorts(:)
    real::dissolved_carbon(nspecies)
    real::fWmin, gas_diffusion_exp, min_anaerobic_resp_factor
end type soil_carbon_pool

!For new functionality: Separate cohorts just for rhizosphere and bulk soil
integer,parameter::RHIZ=1,BULK=2

!---- namelist ---------------------------------------------------------------
real,dimension(nspecies) :: Ea=(/37e3,54e3,50e3/)          !Activation energy (J/mol)
real,dimension(nspecies) :: vmaxref=(/4500e0,25e0,600e0/)  !Vmax at reference temperature (yr-1)
real,dimension(nspecies) :: kC=(/0.01,0.01,0.01/)          !Michaelis-Menton C parameter (dimensionless)
real                     :: Tmic=0.25                      !Microbial turnover rate (yr-1)
real                     :: et=0.6                         !Fraction of microbial turnover not converted to CO2
real,dimension(nspecies) :: eup(nspecies)=(/0.6,0.05,0.6/) !Fraction of respired C that goes into microbial biomass
real                     :: minMicrobeC=1e-3               !Minimum microbial biomass (prevents complete collapse if > 0.0)
real                     :: combineThreshold=1e-2          !Controls when cohorts are combined
real                     :: D=3.0                          !Diffusion coefficient (for carbon and enzyme movement)
real                     :: sol=0.4                        !Substrate solubility (for carbon access by microbes)
real                     :: enzfrac=1.0                    !Relative amount of enzymes produced by microbes
real                     :: tProtected=45.0                !Turnover rate of protected carbon (yr-1)
real                     :: protection_rate=1.5            !Rate that carbon becomes protected (yr-1 kg-microbial-biomass-1)
real,dimension(nspecies) :: protection_species=(/1.0,1.0e-4,1.0/)  !Relative protection rate of each flavor
real                     :: leaching_solubility=0.0       !Rate carbon dissolves in soil water at saturated moisture (yr-1)
real,dimension(nspecies) :: flavor_relative_solubility=(/1.0,1.0,1.0/) !For each C flavor, relative to 1.0
real                     :: protected_relative_solubility=0.0 !Relative to 1.0
real                     :: DOC_deposition_rate=1e10       !Rate carbon is deposited from DOC ((kgC/kgH2O)-1 yr-1)
real                     :: gas_diffusion_exp=2.5          !Exponent for gas diffusion power law dependence on theta_liq
                                                           !See Meslin et al 2010, SSAJ
real                     :: litterDensity=22.0             !C density of litter layer (kg/m3)
                                                           !22.0 roughly from Gaudinsky et al 2000
real                     :: min_anaerobic_resp_factor=0.003  !Minimum for high soil moisture Resp limitation

integer                  :: soilMaxCohorts=2               !Maximum number of cohorts in soil carbon pools
real                     :: tol=1e-8                       !Tolerance for cohort carbon check

logical                  :: CLASSIC_DECOMP=.FALSE.             !Use CENTURY-style (classic) decomposition
logical                  :: microbe_driven_protection=.FALSE.  !Whether to use microbial biomass in protection rate
real                     :: protected_carbon_decomp_factor=0.0 !vmaxref for protected carbon is multiplied by this (0.0 for total protection)
real,dimension(nspecies) :: turnover_factor=(/1.0,1.0,1.0/)    !Factor by which each C species changes microbial turnover time (between 0 and 1)
real                     :: fWmin=0.0                          !Minimum value of f(W) soil mositure effect on respiration (default=0.0)


namelist /soil_carbon_nml/ &
            Ea,vmaxref,kC,Tmic,et,eup,minMicrobeC,combineThreshold,soilMaxCohorts,gas_diffusion_exp,&
            tol,enzfrac,tProtected,protection_rate,protection_species,leaching_solubility,&
            flavor_relative_solubility,DOC_deposition_rate,&
            litterDensity,CLASSIC_DECOMP,protected_relative_solubility,min_anaerobic_resp_factor,&
            microbe_driven_protection,protected_carbon_decomp_factor,turnover_factor,fWmin

contains ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

!-------------------------------------------------------------------------------------------------------------------------------------
! Allocate 2 (max(BULK,RHIZ)) litterCohorts and  
! set protection_rate, Qmax, and max_cohorts for the pool.

subroutine init_soil_carbon(pool,Qmax,max_cohorts)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    real,optional,intent(in) :: Qmax
    integer,optional,intent(in) :: max_cohorts

    !Local variables
    type(litterCohort)::newCohort
    integer:: ii

    ! Default initializations for optional function arguments
    pool%protection_rate=protection_rate
    pool%gas_diffusion_exp=gas_diffusion_exp
    pool%min_anaerobic_resp_factor=min_anaerobic_resp_factor
    pool%fWmin=fWmin
    pool%Qmax=0.0
    pool%max_cohorts=soilMaxCohorts

!   write(*,'(1x,a36,f9.6)') 'init_soil_carbon: protection_rate = ', protection_rate
!   write(*,'(1x,a38,f9.6)') 'init_soil_carbon: gas_diffusion_exp = ', gas_diffusion_exp
!   write(*,'(1x,a46,f9.6)') 'init_soil_carbon: min_anaerobic_resp_factor = ', min_anaerobic_resp_factor
!   write(*,'(1x,a26,f9.6)') 'init_soil_carbon: fWmin = ', fWmin

    pool%dissolved_carbon=0.0

    IF (present(max_cohorts)) pool%max_cohorts=min(max_cohorts,soilMaxCohorts)
    IF (present(Qmax)) pool%Qmax=Qmax

    IF (allocated(pool%litterCohorts)) THEN
        deallocate(pool%litterCohorts)
    ENDIF

    ! valgrind found a problem here: Conditional jump or move depends on uninitialised value(s).
    ! Sometimes size(pool%litterCohorts) starts off as a very large positive or negative number.
    ! If it is a positive number, cohorts won't be allocated correctly and this causes a
    ! segmentation fault later during execution.
    ! -mdh 12/28/2015
    !print *, "init_soil_carbon Before DO WHILE size(pool%litterCohorts) =", size(pool%litterCohorts)
    !DO WHILE(size(pool%litterCohorts)<max(BULK,RHIZ))
    !    call initializeCohort(newCohort)
    !    call add_cohort(pool,newCohort)
    !    print *, "size(pool%litterCohorts) =", size(pool%litterCohorts)
    !ENDDO

    ii = 0
    DO WHILE(ii <max(BULK,RHIZ))
        call initializeCohort(newCohort)
        call add_cohort(pool,newCohort)
        !print *, "size(pool%litterCohorts) =", size(pool%litterCohorts)
        ii = ii + 1
    ENDDO

end subroutine init_soil_carbon



!-------------------------------------------------------------------------------------------------------------------------------------
! #ifdef STANDALONE_SOIL_CARBON
subroutine read_soil_carbon_namelist(file)
implicit none
character*(*),optional,intent(in)::file

integer :: namelistunit
namelistunit=12300
!Read parameters from namelist
if(present(file)) then
    print *,'Reading CORPSE soil parameters from namelist: ',file
    OPEN(unit=namelistunit,file=file)
else
    OPEN(unit=namelistunit,file='corpse_params.nml')
endif
READ(unit=namelistunit,NML=soil_carbon_nml)
CLOSE(unit=namelistunit)
write(*,nml=soil_carbon_nml) 

IF(CLASSIC_DECOMP) THEN
    minMicrobeC=0.0
ENDIF


end subroutine
! #endif


!-------------------------------------------------------------------------------------------------------------------------------------
! Main subroutine for updating the state of a soil C pool.  It iterates through all the cohorts
! within the pool and calls update_cohort for each to do respiration, microbial growth and turnover,
! and protected C formation and turnover.  

subroutine update_pool(pool,T,theta_liq,air_filled_porosity,liquid_water,frozen_water,dt,layerThickness,&
            fast_C_loss_rate,slow_C_loss_rate,deadmic_C_loss_rate,CO2prod,deadmic_produced,&
            protected_produced,protected_turnover_rate,&
            C_dissolved,deposited_C,badCohort,npt,doy,hr)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    real,intent(in)::T,theta_liq,dt,air_filled_porosity,liquid_water,frozen_water,layerThickness
    real,intent(out)::fast_C_loss_rate,slow_C_loss_rate,deadmic_C_loss_rate,CO2prod,&
            protected_produced(nspecies),protected_turnover_rate(nspecies),deadmic_produced
    real,intent(out)::C_dissolved(nspecies),deposited_C(nspecies)
    integer,intent(out),optional::badCohort
    integer,intent(in),optional::npt,doy,hr
    ! dt is in years!

    integer::n
    real::tempresp(nspecies),resp(nspecies),temp_protected(nspecies),&
            tempCO2,temp_protected_turnover_rate(nspecies),&
            Prate_limited(nspecies),prevC(nspecies),temp_deadmic
    !real poolProtectedC
    real::dissolution_rate,liquid_frac
    real::protected_dissolved(nspecies),livemicrobe_dissolved
    real::cohortVolume(pool%max_cohorts),activeVolume,inactiveVolume
    real::protected_solubility

    resp=0.0
    CO2prod=0.0
    protected_produced=0.0
    protected_turnover_rate=0.0
    deadmic_produced=0.0

    if(present(badCohort)) badCohort=0

    if(.NOT.allocated(pool%litterCohorts)) call add_litter(pool,(/0.0,0.0,0.0/))
    call cull_cohorts(pool)

! Commented out the dissolved C calculation to immprove execution time
! as suggested by Ben Sulman 3/16/2016 (-mdh 3/21/2016)
!   !Update dissolved carbon
!   !If there is liquid water, it exchanges carbon with the soil
!   !If all the water is frozen, there is no exchange
!   !If there is no water at all, then any dissolved carbon is dumped into the soil
!   if(liquid_water > 0.0) then
!       liquid_frac=liquid_water/(liquid_water+frozen_water)
!       deposited_C=DOC_deposition_rate*pool%dissolved_carbon*liquid_frac*dt
!       dissolution_rate=leaching_solubility*theta_liq
!       where(deposited_C > pool%dissolved_carbon)
!           deposited_C=pool%dissolved_carbon
!           pool%dissolved_carbon=0.0
!       elsewhere
!           pool%dissolved_carbon=pool%dissolved_carbon-deposited_C
!       end where
!
!       !Protected carbon can dissolve, but much faster under high moisture conditions
!       protected_solubility=theta_liq**gas_diffusion_exp*protected_relative_solubility
!       if (protected_solubility<0.0) protected_solubility=0.0
!       if (protected_solubility>1.0) protected_solubility=1.0
!
!       call remove_carbon_fraction_from_pool(pool,dissolution_rate*dt,&
!               litter_removed=C_dissolved,protected_removed=protected_dissolved,&
!               livemicrobe_removed=livemicrobe_dissolved,&
!               protectedMobility=protected_solubility,livingMicrobeMobility=0.0,&
!               litterMobility=flavor_relative_solubility)
!
!       C_dissolved=C_dissolved+protected_dissolved
!       protected_turnover_rate=protected_turnover_rate+protected_dissolved/dt
!   elseif(frozen_water > 0.0) then
!       deposited_C=0.0
!       C_dissolved=0.0
!   else
!       deposited_C=DOC_deposition_rate*pool%dissolved_carbon*dt
!       where(deposited_C > pool%dissolved_carbon)
!           deposited_C=pool%dissolved_carbon
!           pool%dissolved_carbon=0.0
!       elsewhere
!           pool%dissolved_carbon=pool%dissolved_carbon-deposited_C
!       end where
!       C_dissolved=0.0
!   endif
!
!   call add_carbon_to_cohorts(pool,litterC=deposited_C)
!   pool%dissolved_carbon=pool%dissolved_carbon+C_dissolved



    !Protection rate is multiplied by available space, so protected C does not exceed Pmax
    !However, the rate is not adjusted for each cohort, so it may go slightly above the pool Pmax
    ! ---   Based on conversation with Melanie Mayes, I am changing this so Qmax affects the protected
    ! ---   carbon formation rate rather than the maximum.
!    call poolTotalCarbon(pool,protectedC=poolProtectedC)
!    IF (pool%Pmax.eq.0.0) THEN
!        Prate_limited=0.0
!    ELSE
!        Prate_limited=max(0.0,pool%protection_rate*protection_species*(1.0-poolProtectedC/pool%Pmax))
!    ENDIF
    Prate_limited=pool%protection_rate*protection_species*pool%Qmax

    !Need to convert originalLitterC into a meaningful volume, since it will keep increasing as cohorts are combined
    !How about this: non-mineralized C keeps volume based on estimated density
    !Volume of mineralized C is just capped at remaining layer volume, with the assumption that the mineralized portion
    !of volume for all cohorts just gets intermingled and doesn't need to sum to layer volume
    do n=1, size(pool%litterCohorts)
        activeVolume=cohortCsum(pool%litterCohorts(n),.TRUE.)/litterDensity
        inactiveVolume=min(pool%litterCohorts(n)%originalLitterC/litterDensity,layerThickness)-activeVolume
        cohortVolume(n)=activeVolume+max(0.0,inactiveVolume)
    enddo


    DO n=1,size(pool%litterCohorts)
        prevC=pool%litterCohorts(n)%litterC
        call update_cohort(pool%litterCohorts(n),cohortVolume(n),T,max(theta_liq,0.0),max(air_filled_porosity,0.0),&
                        Prate_limited,dt,tempresp,temp_deadmic,temp_protected,temp_protected_turnover_rate,tempCO2)
        IF (.NOT. check_cohort(pool%litterCohorts(n))) THEN
            if(present(badCohort)) badCohort=n
            WRITE (*,*) 'UPDATE_POOL: Cohort',n,'of',size(pool%litterCohorts),'bad'
            call print_cohort(pool%litterCohorts(n))
            WRITE (*,*) 'Dissolved carbon =',pool%dissolved_carbon
            WRITE (*,*) 'Latest respiration:',tempResp*dt
            WRITE (*,*) 'Previous unprotected C:',prevC
            WRITE (*,*) 'npt =', npt, 'doy =',doy, 'hour = ', hr
            if (.NOT. present(badCohort)) call error_mesg('Update_pool','Bad cohort',FATAL)
        ENDIF

        resp=resp+tempresp
        protected_produced=protected_produced+temp_protected
        protected_turnover_rate=protected_turnover_rate+temp_protected_turnover_rate
        deadmic_produced=deadmic_produced+temp_deadmic
        CO2prod=CO2prod+tempCO2
    ENDDO

    if (protected_produced(1) > 0.99) then
        WRITE (*,*) 'WARNING: npt =', npt, 'doy =',doy
        WRITE (*,*) 'UPDATE_POOL: protected_produced(1) = ', protected_produced(1) 
    endif 

    fast_C_loss_rate=resp(1)
    slow_C_loss_rate=resp(2)
    deadmic_C_loss_rate=resp(3)
end subroutine update_pool


!-------------------------------------------------------------------------------------------------------------------------------------
!Do litter respiration and microbial turnover for one litter cohort
subroutine update_cohort(cohort,cohortVolume,T,theta_liq,air_filled_porosity,protection_rate,dt,totalResp,&
    deadmic_produced,protected_produced,protected_turnover_rate,CO2prod)

    implicit none
    type(litterCohort),intent(inout)::cohort
    real,intent(out)::totalResp(nspecies),CO2prod,protected_produced(nspecies), &
                      protected_turnover_rate(nspecies),deadmic_produced
    real,intent(in)::cohortVolume,T,theta_liq,dt,protection_rate(nspecies) !Temperature, volumetric water content, delta time
    real,intent(in)::air_filled_porosity

    real::microbeTurnover,temp_microbes
    !real::oldminC(nspecies)
    real::tempResp(nspecies)
    real,dimension(nspecies)::protectedCTurnover,newProtectedC

    totalResp=0.0
    tempResp=0.0
    CO2prod=0.0
    deadmic_produced=0.0

    !Decompose carbon pools
    !Litter

    tempResp=Resp(cohort%litterC,cohort%livingMicrobeC,T,theta_liq,air_filled_porosity)

    where(dt*tempResp > cohort%litterC)
        tempResp=cohort%litterC/dt
        cohort%litterC=0.0
    elsewhere
        cohort%litterC=cohort%litterC-dt*tempResp
    end where


    totalResp=totalResp+tempResp

    !Protected carbon
    tempResp=Resp(cohort%protectedC,cohort%livingMicrobeC,T,theta_liq,air_filled_porosity, &
                  vmax_factor=protected_carbon_decomp_factor)

    where(dt*tempResp > cohort%protectedC)
        tempResp=cohort%protectedC/dt
        cohort%protectedC=0.0
    elsewhere
        cohort%protectedC=cohort%protectedC-dt*tempResp
    end where

    totalResp=totalResp+tempResp


    !Update microbial biomass
    temp_microbes=cohort%livingMicrobeC
    IF(.NOT. CLASSIC_DECOMP) THEN
        microbeTurnover=max(0.0,(cohort%livingMicrobeC-minMicrobeC*sum(cohort%litterC))/Tmic)
        if(sum(totalResp)>0) microbeTurnover=microbeTurnover*1.0/(sum(totalResp/sum(totalResp)*1.0/turnover_factor))
        cohort%livingMicrobeC=cohort%livingMicrobeC + dt*(sum(eup*totalResp) - microbeTurnover)
        deadmic_produced=dt*microbeTurnover*et
        cohort%litterC(3)=cohort%litterC(3)+deadmic_produced
        CO2prod=dt*(sum(totalResp*(1.0-eup))+microbeTurnover*(1.0-et))
    ENDIF
    IF(cohort%livingMicrobeC<0) then
        print *,'Live microbe C',cohort%livingMicrobeC
        print *,'Respired C',totalResp*dt
        print *,'microbe turnover',dt*microbeTurnover
        print *,'Previous microbe C',temp_microbes
        print *,'dt',dt
        call print_cohort(cohort)
        call error_mesg('update_cohort','Microbe C < 0',FATAL)
    ENDIF
    cohort%CO2=cohort%CO2+CO2prod


    !Update protected carbon
    protectedCturnover = cohort%protectedC/tProtected
    IF(sum(cohort%litterC).gt.0.0 .and. cohortVolume.gt.0.0) THEN
        !microbe_drive_protection gives the option to turn on and off the microbial role in protected C formation
        if (microbe_driven_protection) then
            newProtectedC(:) = protection_rate*cohort%livingMicrobeC/cohortVolume*cohort%litterC(:)*dt
        else
            newProtectedC(:) = protection_rate*cohort%litterC(:)*dt
        endif
    ELSE
        newProtectedC = 0.0
    ENDIF
    where(newProtectedC.gt.cohort%litterC) newProtectedC=cohort%litterC
    cohort%protectedC = cohort%protectedC + newProtectedC - dt*protectedCturnover
    cohort%litterC = cohort%litterC - newProtectedC + dt*protectedCturnover

    protected_produced=newProtectedC
    protected_turnover_rate=protectedCturnover

    cohort%Rtot=cohort%Rtot+sum(totalResp)
end subroutine update_cohort


!-------------------------------------------------------------------------------------------------------------------------------------
! Initialize 3 unprotected, 3 protected, and the living microbe pools in the litterCohort named cohort.

subroutine initializeCohort(cohort,litterInputC,initialMicrobeC,initialProtectedC,multiplier,CO2)
    implicit none
    type(litterCohort),intent(out)::cohort
    real,intent(in),optional::litterInputC(nspecies)
    real,intent(in),optional::initialMicrobeC
    real,intent(in),optional::initialProtectedC(nspecies)
    real,intent(in),optional::multiplier
    real,intent(in),optional::CO2
 
    !Local Variables
    real::litterInputCval(nspecies)
    real::initialMicrobeCval
    real::initialProtectedCval(nspecies)
    real::multiplierval
    real::CO2val

    litterInputCval=0.0
    !initialMinC=0.0
    initialProtectedCval=0.0
    initialMicrobeCval=0.0
    CO2val=0.0
    multiplierval=1.0

    if (present(litterInputC)) litterInputCval=litterInputC
    !if (present(initialMinC)) initialMinCval=initialMinC
    if (present(initialprotectedC)) initialProtectedCval=initialProtectedC
    if (present(initialMicrobeC)) initialMicrobeCval=initialMicrobeC
    if (present(CO2)) CO2val=CO2
    if (present(multiplier)) multiplierval=multiplier


    !originalLitterC is there to check carbon conservation
    cohort%originalLitterC=(sum(litterInputCval)+CO2val+initialMicrobeCval+sum(initialProtectedCval))*multiplierval
    cohort%litterC=litterInputCval*multiplierval
    cohort%protectedC=initialProtectedCval*multiplierval
    !cohort%minC=initialMinCval*multiplierval
    cohort%livingMicrobeC=initialMicrobeCval*multiplierval
    cohort%CO2=CO2val*multiplierval
    cohort%Rtot=0.0

end subroutine initializeCohort


!-------------------------------------------------------------------------------------------------------------------------------------
! Calculate respriation rate (kgC/m2/yr) using microbial biomass, Vmax, and moisture function
function Resp(Ctotal,Chet,T,theta_liq,air_filled_porosity,vmax_factor)
    real,intent(in)::Chet                       !heterotrophic (microbial) C
    real,intent(in)::T,theta_liq                !temperature (k), theta (liquid fraction of 1.0)
    real,intent(in)::air_filled_porosity        !Fraction of 1.0.  Different from 1.0-theta_liq since it includes ice
    real,intent(in),dimension(nspecies)::Ctotal !Substrate C
    real,intent(in),optional :: vmax_factor     !Multiply vmax by this factor

    !Local Variables
    real,dimension(nspecies)::Resp
    !real,dimension(nspecies)::tempresp
    real::enz,Cavail(nspecies),vmax_multiplier
    real :: fW

    vmax_multiplier=1.0
    if (present(vmax_factor)) vmax_multiplier=vmax_factor

    enz=Chet*enzfrac

    !Available carbon is the amount that diffuses to enzyme site
    !Cavail=Ctotal*sol*D*theta_liq**3
    !Available carbon is the amount that is not in saturated soil fraction
    !Cavail=Ctotal*(1.0-theta_liq)
    !Power law dependence on soil moisture, see below

    Cavail=Ctotal
    IF(sum(Cavail) .eq. 0.0 .OR. theta_liq .eq. 0.0 .OR. enz .eq. 0.0) THEN
        Resp=0.0
        return
    ENDIF

    ! Put a lower limit of 0.001 on theta_liq^3 (w.wieder, 11/7/2016).
!   Resp=Vmax(T)*vmax_multiplier*theta_liq**3*(Cavail)*enz/(sum(Cavail)*kC+enz) &
!        *max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor)
!   Resp=Vmax(T)*vmax_multiplier*(theta_liq**3+0.001)*(Cavail)*enz/(sum(Cavail)*kC+enz) &
!        *max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor)
    !Set minimum soil water effect to namelist parameter fWmin. -mdh 12/18/2017
    fW = max(fWmin,(theta_liq**3+0.001)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor))
    Resp=Vmax(T)*vmax_multiplier*fW*(Cavail)*enz/(sum(Cavail)*kC+enz)
         

    !ox_avail=oxygen_concentration(Ox,sum(tempresp)/sum(Cavail)*theta_liq*oxPerC)
    !print *,sum(tempresp)/sum(Cavail)
    !print *,ox_avail/(kO+ox_avail)
    !print *,tempresp*(1.0-theta_liq)+theta_liq*tempresp*ox_avail/(kO+ox_avail)

    !Assumes pores are either saturated or not oxygen limited, divided according to theta_liq
    !Resp=tempresp*(1.0-theta_liq)+theta_liq*tempresp*ox_avail/(kO+ox_avail)
end function Resp


!-------------------------------------------------------------------------------------------------------------------------------------
function Vmax(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(nspecies)::alpha,Vmax

    alpha=vmaxref/exp(-Ea/(Rugas*Tref))
    Vmax=alpha*exp(-Ea/(Rugas*T))
end function Vmax


!-------------------------------------------------------------------------------------------------------------------------------------
subroutine print_cohort(cohort)
    implicit none
    type(litterCohort)::cohort

    WRITE (*,*) '----------------'
    WRITE (*,*) 'Original C =',cohort%originalLitterC
    WRITE (*,*) 'Unprotected C=',cohort%litterC
    WRITE (*,*) 'Living microbial C =',cohort%livingMicrobeC
    !WRITE (*,*) 'Microbial products =',cohort%microbProdC
    WRITE (*,*) 'Protected C =',cohort%protectedC

    !WRITE (*,*) 'Mineral complex C =',cohort%minC
    WRITE (*,*) 'CO2 =',cohort%CO2
    WRITE (*,*) 'Rtot =',cohort%Rtot
    !WRITE (*,*) 'Volume fraction =',cohort%cohortVolume
    WRITE (*,*) 'Sum of carbon =',cohortCsum(cohort)
    WRITE (*,*) 'Difference = ',cohortCsum(cohort)-cohort%originalLitterC
    if (cohort%originalLitterC > 0.0) then
        WRITE(*,*) 'Fractional difference =',(cohortCsum(cohort)-cohort%originalLitterC)/cohort%originalLitterC
    else
        WRITE(*,*) 'Fractional difference = 0.0'
    endif

    WRITE (*,*) '----------------'
end subroutine


!Check for carbon balance and invalid values
logical function check_cohort(cohort) result(cohortGood)
    type(litterCohort),intent(in)::cohort
    integer::n
    logical:: tempGood
    real :: cohortC

    cohortGood=.NOT. ( &
     (min(cohort%originalLitterC,cohort%livingMicrobeC,cohort%CO2).lt.0) .OR. &
    isNAN(cohort%originalLitterC) .OR. &
    isNAN(cohort%livingMicrobeC) .OR. &
    isNAN(cohort%CO2)  &
    )

   cohortC=cohortCSum(cohort)
  if(cohortC .GT. 0.0) cohortGood = cohortGood .AND. ( (abs(cohortC-cohort%originalLitterC)/cohortC) .LT. tol &
                       .OR. abs(cohortC-cohort%originalLitterC).LT.1e-10)

    DO n=1,nspecies
        tempGood = .NOT. ( &
        (cohort%litterC(n).lt.0) .OR. &
        (isNAN(cohort%litterC(n))) .OR. &
        (isNAN(cohort%protectedC(n)))  &
        )
        cohortGood=cohortGood .AND. tempGood
    ENDDO

   ! IF(cohortBad) THEN
!        WRITE (*,*)'Cohort carbon pool error:'
!        call print_cohort(cohort)
!        WRITE (*,*)'Sum =',cohortCSum(cohort),'Difference =',cohortCSum(cohort)-(cohort%originalLitterC)

        !This should be changed to a model-friendly error
!#ifdef STANDALONE_SOIL_CARBON
!        !STOP
!#else
!        !call error_mesg('check_cohort','Error in cohort value',FATAL)
!#endif
!    !ENDIF
end function check_cohort



function cohortCSum(cohort,only_active)
    type(litterCohort),intent(in)::cohort
    logical,intent(in),optional::only_active
    real::tempSum
    real::cohortCSum

    logical::only_act

    only_act=.FALSE.
    if(present(only_active)) only_act=only_active


    tempSum=0.0
    tempSum=tempSum+cohort%livingMicrobeC
    tempSum=tempSum+sum(cohort%litterC)
    tempSum=tempSum+sum(cohort%protectedC)
    !tempSum=tempSum+sum(cohort%minC)
    if (.NOT. only_act) then
        tempSum=tempSum+cohort%CO2
    endif
    cohortCSum=tempSum
END FUNCTION


!-------------------------------------------------------------------------------------------------------------------------------------
! Add a cohort to the soil carbon pool
!
! Notes:  I am suspecting a problem with this subroutine
! The exisiting cohorts are assigned to a local variable newCohorts(*)
! then are deallocated.  newCohorts * are assigned to pool%litterCohorts
! then the local varaible newCohorts are deallocated.
! I am wondering if the assignement results in a copy or a assignment 
! of a memory location. If there is no copy, then the final deallocation
! might be causing the problem.
! Why not just add a cohort to pool%litterCohorts insted of this copy and
! delete and reassignment. -mdh 12/27/2015

! The derived-type assignment is performed as if each component of the expression is assigned 
! to the corresponding component of the variable. Pointer assignment is performed for pointer 
! components, and intrinsic assignment is performed for nonpointer components.

subroutine add_cohort(pool,newCohort)
    implicit none
    type(soil_carbon_pool),intent(inout) :: pool
    type(litterCohort),intent(in) :: newCohort

    integer::nCohorts

    type(litterCohort),allocatable::newCohorts(:)


    IF (allocated(pool%litterCohorts)) THEN
        nCohorts=size(pool%litterCohorts)
    ELSE
        nCohorts=0
    ENDIF

    allocate(newCohorts(nCohorts+1))
    IF (nCohorts.ge.1)  newCohorts(1:nCohorts)=pool%litterCohorts


    newCohorts(nCohorts+1)=newCohort

    IF(allocated(pool%litterCohorts)) deallocate(pool%litterCohorts)
    allocate(pool%litterCohorts(nCohorts+1))
    pool%litterCohorts=newCohorts     ! Is this a copy or memory assignment?
    deallocate(newCohorts)

end subroutine


!-------------------------------------------------------------------------------------------------------------------------------------
! Adds litter as a new cohort

subroutine add_litter(pool,newLitterC,rhizosphere_frac)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    real,intent(in) :: newLitterC(nspecies)
    real,intent(in),optional :: rhizosphere_frac

    type(litterCohort)::newCohort,tempCohort
    real::initialMicrobeC
    real::rhiz_frac

    rhiz_frac=1.0
    if(present(rhizosphere_frac)) rhiz_frac=max(0.0,min(1.0,rhizosphere_frac))

    !if(any(newLitterC < 0.0)) call error_mesg('add_litter','Some of new litter less than zero',FATAL)
    if(any(newLitterC < 0.0)) call error_mesg('add_litter','Some of new litter less than zero',NOTE)
    initialMicrobeC=sum(newLitterC*minMicrobeC)

    !call initializeCohort(newCohort,litterInputC=newLitterC*(1.0-minMicrobeC),initialMicrobeC=initialMicrobeC)
    !call add_cohort(pool,newCohort)

    !New function: Just split between rhizosphere and bulk soil
    DO WHILE (size(pool%litterCohorts)<max(BULK,RHIZ))
        call initializeCohort(newCohort)
        call add_cohort(pool,newCohort)
    ENDDO


    !Add rhizosphere fraction
    call initializeCohort(newCohort,litterInputC=newLitterC*(1.0-minMicrobeC),&
                          initialMicrobeC=initialMicrobeC,multiplier=rhiz_frac)
    call combine_cohorts(newCohort,pool%litterCohorts(RHIZ),tempCohort)  !! Segmentation Fault was inside this call
    pool%litterCohorts(RHIZ)=tempCohort


    !Add bulk soil fraction
    call initializeCohort(newCohort,litterInputC=newLitterC*(1.0-minMicrobeC),&
                          initialMicrobeC=initialMicrobeC,multiplier=1.0-rhiz_frac)
    call combine_cohorts(newCohort,pool%litterCohorts(BULK),tempCohort)
    pool%litterCohorts(BULK)=tempCohort

end subroutine add_litter

!-------------------------------------------------------------------------------------------------------------------------------------
! Adds litter to existing litterCohorts
! Experimental subroutine. Equivalent to add_litter but makes fewer calls to other subroutines for computational efficiency.

subroutine add_litter2(pool,newLitterC,rhizosphere_frac)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    real,intent(in) :: newLitterC(nspecies)
    real,intent(in),optional :: rhizosphere_frac

    !Local Variables
    real::rhiz_frac
    real::zeroThreshold

    zeroThreshold = -10.0e-5

    rhiz_frac=1.0
    if(present(rhizosphere_frac)) rhiz_frac=max(0.0,min(1.0,rhizosphere_frac))

    !if(any(newLitterC < 0.0)) call error_mesg('add_litter2','Some of new litter less than zero',FATAL)
    !if(any(newLitterC < 0.0)) call error_mesg('add_litter2','Some of new litter less than zero',NOTE)
    if(any(newLitterC < zeroThreshold)) call error_mesg('add_litter2','Some of new litter less than zero',NOTE)

    IF (size(pool%litterCohorts) < 1) THEN
        !call error_mesg('add_litter2','Litter Cohorts unallocated',FATAL)
        call error_mesg('add_litter2','Litter Cohorts unallocated',NOTE)
    ENDIF

    IF (size(pool%litterCohorts) >= 1) THEN
        !Add rhizosphere fraction

        pool%litterCohorts(RHIZ)%litterC(LABILE)     = pool%litterCohorts(RHIZ)%litterC(LABILE) &
                                                       + newLitterC(LABILE)*(1.0-minMicrobeC)*rhiz_frac

        pool%litterCohorts(RHIZ)%litterC(RECALCTRNT) = pool%litterCohorts(RHIZ)%litterC(RECALCTRNT) &
                                                       + newLitterC(RECALCTRNT)*(1.0-minMicrobeC)*rhiz_frac

        pool%litterCohorts(RHIZ)%litterC(DEADMICRB)  = pool%litterCohorts(RHIZ)%litterC(DEADMICRB) &
                                                       + newLitterC(DEADMICRB)*(1.0-minMicrobeC)*rhiz_frac

        pool%litterCohorts(RHIZ)%livingMicrobeC = pool%litterCohorts(RHIZ)%livingMicrobeC &
                                                  + sum(newLitterC)*minMicrobeC*rhiz_frac
        ! Save total C in the cohort for checking C balance later
        pool%litterCohorts(RHIZ)%originalLitterC = cohortCsum(pool%litterCohorts(RHIZ))

    ENDIF 

    IF (size(pool%litterCohorts) >= 2) THEN
        !Add bulk soil fraction
        pool%litterCohorts(BULK)%litterC(LABILE)     = pool%litterCohorts(BULK)%litterC(LABILE) &
                                                       + newLitterC(LABILE)*(1.0-minMicrobeC)*(1.0-rhiz_frac)

        pool%litterCohorts(BULK)%litterC(RECALCTRNT) = pool%litterCohorts(BULK)%litterC(RECALCTRNT) &
                                                       + newLitterC(RECALCTRNT)*(1.0-minMicrobeC)*(1.0-rhiz_frac)

        pool%litterCohorts(BULK)%litterC(DEADMICRB)  = pool%litterCohorts(BULK)%litterC(DEADMICRB) &
                                                       + newLitterC(DEADMICRB)*(1.0-minMicrobeC)*(1.0-rhiz_frac)

        pool%litterCohorts(BULK)%livingMicrobeC = pool%litterCohorts(BULK)%livingMicrobeC &
                                                      + sum(newLitterC)*minMicrobeC*(1.0-rhiz_frac)
        ! Save total C in the cohort for checking C balance later
        pool%litterCohorts(BULK)%originalLitterC = cohortCsum(pool%litterCohorts(BULK))

    ENDIF

end subroutine add_litter2


!-------------------------------------------------------------------------------------------------------------------------------------
!Add carbon to all cohorts in pool, weighted by cohort size.
!For leaching or exudation that is spread evenly in soil instead of new cohort
subroutine add_carbon_to_cohorts(pool,litterC,protectedC,livingMicrobeC,CO2)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    real,optional,dimension(nspecies),intent(in)::litterC,protectedC
    real,optional,intent(in)::livingMicrobeC,CO2

    real,dimension(nspecies)::litterCval,protectedCval
    real::livingMicrobeCval,CO2val
    real::totalCarbon,weight
    integer::ii

    livingMicrobeCval=0.0
    protectedCval=0.0
    litterCval=0.0
    CO2val=0.0

    IF (present(litterC)) litterCval=litterC
    IF (present(protectedC)) protectedCval=protectedC
    IF (present(livingMicrobeC)) livingMicrobeCval=livingMicrobeC
    IF (present(CO2)) CO2val=CO2

    IF (any(litterCval<0) .or. any(protectedCval<0) .or. livingMicrobeCval<0 .or. CO2val<0) &
          call error_mesg('add_carbon_to_cohorts','Carbon added less than zero',FATAL)

    call poolTotalCarbon(pool,totalCarbon=totalCarbon)
    if(.not.allocated(pool%litterCohorts)) call add_litter(pool,(/0.0,0.0,0.0/))
    DO ii=1,size(pool%litterCohorts)
        !Deposited carbon is just weighted by total cohort carbon
        IF(totalCarbon.gt.0) THEN
        weight=cohortCsum(pool%litterCohorts(ii),only_active=.TRUE.)/totalCarbon
        ELSE
        weight=1.0
        ENDIF

        pool%litterCohorts(ii)%litterC=pool%litterCohorts(ii)%litterC+litterCval*weight
        pool%litterCohorts(ii)%protectedC=pool%litterCohorts(ii)%protectedC+protectedCval*weight
        pool%litterCohorts(ii)%livingMicrobeC=pool%litterCohorts(ii)%livingMicrobeC+livingMicrobeCval*weight
        pool%litterCohorts(ii)%CO2=pool%litterCohorts(ii)%CO2+CO2val*weight
        pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC&
                                               +(sum(litterCval+protectedCval)+livingMicrobeCval+CO2val)*weight
    ENDDO

end subroutine


!-------------------------------------------------------------------------------------------------------------------------------------
subroutine add_carbon_to_rhizosphere(pool,newCarbon)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    real,intent(in)::newCarbon(nspecies)

    type(litterCohort)::rhizosphere,newcohort
    !real::litter_removed(nspecies),protected_removed(nspecies),liveMicrobe_removed
    !integer::n

    !call remove_carbon_fraction_from_pool(pool,rhizosphere_frac,litter_removed,protected_removed,liveMicrobe_removed)

    call initializeCohort(newcohort,newCarbon)

    !call add_cohort(pool,rhizosphere)
    !do n=1,size(pool%litterCohorts)
    !IF (.NOT. check_cohort(pool%litterCohorts(n))) THEN
    !        WRITE (*,*),'add_carbon_to_rhizosphere: Cohort',n,'of',size(pool%litterCohorts),'bad'
    !        call print_cohort(pool%litterCohorts(n))
    !        call error_mesg('add_carbon_to_rhizosphere','Bad cohort',FATAL)
    !ENDIF
    !enddo

    !New functionality: Rhizosphere is a fixed cohort, just add carbon to that
    !Ignores rhizosphere_frac I guess
    call combine_cohorts(newcohort,pool%litterCohorts(RHIZ),rhizosphere)
    pool%litterCohorts(RHIZ)=rhizosphere
end subroutine



!-------------------------------------------------------------------------------------------------------------------------------------
!Remove a fraction of carbon from all cohorts.  For processes like leaching and bioturbation
subroutine remove_carbon_fraction_from_pool(pool,fraction,litter_removed,protected_removed,liveMicrobe_removed,&
                                            litterMobility,protectedMobility,livingMicrobeMobility)
    implicit none
    type(soil_carbon_pool),intent(inout) :: pool
    real,intent(in) :: fraction
    real,intent(out) :: litter_removed(nspecies),protected_removed(nspecies),liveMicrobe_removed
    real,intent(in), optional :: litterMobility(nspecies),protectedMobility,livingMicrobeMobility

    integer::ii
    real::temp,temp2(nspecies)
    real::litterFactor(nspecies),protectedFactor,liveMicrobeFactor

    litterFactor=1.0
    protectedFactor=1.0
    liveMicrobeFactor=1.0

    IF (present(litterMobility)) litterFactor=litterMobility
    IF (present(protectedMobility)) protectedFactor=protectedMobility
    IF (present(livingMicrobeMobility)) liveMicrobeFactor=livingMicrobeMobility

    if(fraction>1.0) call error_mesg('remove_carbon_fraction_from_pool','fraction > 1.0',FATAL)

    litter_removed=0.0
    protected_removed=0.0
    liveMicrobe_removed=0.0

    IF(allocated(pool%litterCohorts)) THEN
    DO ii=1,size(pool%litterCohorts)
        temp2=pool%litterCohorts(ii)%litterC*min(1.0,fraction)*litterFactor
        litter_removed=litter_removed+temp2
        pool%litterCohorts(ii)%litterC=pool%litterCohorts(ii)%litterC-temp2
        pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-sum(temp2)

        temp2=pool%litterCohorts(ii)%protectedC*min(1.0,fraction)*protectedFactor
        protected_removed=protected_removed+temp2
        pool%litterCohorts(ii)%protectedC=pool%litterCohorts(ii)%protectedC-temp2
        pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-sum(temp2)

        temp=pool%litterCohorts(ii)%livingMicrobeC*min(1.0,fraction)*liveMicrobeFactor
        liveMicrobe_removed=liveMicrobe_removed+temp
        pool%litterCohorts(ii)%livingMicrobeC=pool%litterCohorts(ii)%livingMicrobeC-temp
        pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-temp
    ENDDO
    ENDIF
end subroutine


!-------------------------------------------------------------------------------------------------------------------------------------
subroutine remove_cohort(pool,num)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool
    integer,intent(in)::num

    type(litterCohort),allocatable::newCohorts(:)
    integer::nCohorts

    nCohorts=size(pool%litterCohorts)

    !PRINT *,'Removing cohort',num
    IF (num .gt. nCohorts) call error_mesg('remove_cohort','Tried to remove nonexistent soil cohort',FATAL)

    allocate(newCohorts(nCohorts-1))
    IF (num.eq.1) THEN
        newCohorts=pool%litterCohorts(2:nCohorts)
    ELSE IF (num.eq.nCohorts) THEN
        newCohorts=pool%litterCohorts(1:nCohorts-1)
    ELSE
        newCohorts(1:num-1)=pool%litterCohorts(1:num-1)
        newCohorts(num:nCohorts-1)=pool%litterCohorts(num+1:nCohorts)
    ENDIF

    deallocate(pool%litterCohorts)
    allocate(pool%litterCohorts(nCohorts-1))
    pool%litterCohorts=newCohorts
    deallocate(newCohorts)

    !PRINT *,nCohorts,'cohorts left'
end subroutine



!-------------------------------------------------------------------------------------------------------------------------------------
! Adds the pools from two litterCohorts and returns the sums the result litterCohort

subroutine combine_cohorts(cohort1,cohort2,result)
    implicit none
    type(litterCohort),intent(in)::cohort1,cohort2
    type(litterCohort),intent(out)::result

    !real::totalVolume,Cbefore,Cafter

    call initializeCohort(result)

!   print *, "size(result%litterC) =", size(result%litterC)
!   print *, "size(cohort1%litterC) =", size(cohort1%litterC)
!   print *, "size(cohort2%litterC) =", size(cohort2%litterC)
!   print *, "combine_cohorts result: "
!   call print_cohort(result)
!   print *, "combine_cohorts cohort1: "
!   call print_cohort(cohort1)
!   print *, "combine_cohorts cohort2: "
!   call print_cohort(cohort2)

    result%litterC=cohort1%litterC + cohort2%litterC  ! Segmentation Fault occurs here
    result%protectedC=cohort1%protectedC + cohort2%protectedC

    result%livingMicrobeC=cohort1%livingMicrobeC + cohort2%livingMicrobeC
    result%CO2=cohort1%CO2 + cohort2%CO2
    result%Rtot=cohort1%Rtot + cohort2%Rtot
    result%originalLitterC=cohort1%originalLitterC + cohort2%originalLitterC

    !Cbefore=cohortCsum(cohort1)*cohort1%cohortVolume+cohortCsum(cohort2)*cohort2%cohortVolume
    !Cafter=cohortCsum(result)*result%cohortVolume

    !IF (Cbefore.ne.Cafter) PRINT *,'Error in combining cohorts:',Cafter-Cbefore

end subroutine

!-------------------------------------------------------------------------------------------------------------------------------------
!Returns the cohort with all fields multiplied by x
function multiply_cohort(cohort,x) result(result)
    type(litterCohort),intent(in) :: cohort
    real,intent(in) :: x
    type(litterCohort) :: result

    call initializeCohort(result,cohort%litterC,cohort%livingMicrobeC,cohort%protectedC,x,cohort%CO2)
    result%Rtot=cohort%Rtot*x

end function multiply_cohort


!-------------------------------------------------------------------------------------------------------------------------------------
!Combine two soil_carbon_pool pools, with weighting
subroutine combine_pools(pool1,pool2,w1,w2)
    implicit none
    type(soil_carbon_pool),intent(in) :: pool1
    type(soil_carbon_pool),intent(inout) :: pool2
    real :: w1,w2,x1,x2
    integer::cc

    ! Make sure weights are normalized
    x1 = w1/(w1+w2)
    x2 = 1.0 - x1

    !First multiply existing cohorts by weighting
    DO cc=1,size(pool2%litterCohorts)
        pool2%litterCohorts(cc)=multiply_cohort(pool2%litterCohorts(cc),x2)
    ENDDO

    !Then just add the cohorts in pool1 to pool2, with weights
    DO cc=1,size(pool1%litterCohorts)
        call add_cohort(pool2,multiply_cohort(pool1%litterCohorts(cc),x1))
    ENDDO

    call cull_cohorts(pool2)
    pool2%dissolved_carbon=pool2%dissolved_carbon*x2 + pool1%dissolved_carbon*x1


end subroutine combine_pools

!-------------------------------------------------------------------------------------------------------------------------------------
!transfers a fraction of one pool into another, preserving cohorts
subroutine transfer_pool_fraction(source, destination, fraction)
    implicit none
    type(soil_carbon_pool), intent(inout) :: source, destination
    real, intent(in) :: fraction

    integer::nn
    type(litterCohort)::transfer_cohort,tempCohort

    if(fraction>1.0) call error_mesg('transfer_pool_fraction','fraction > 1.0',FATAL)
    if(fraction<0.0) call error_mesg('transfer_pool_fraction','fraction < 0.0',FATAL)

    do nn=1,size(source%litterCohorts)
        transfer_cohort=multiply_cohort(source%litterCohorts(nn),fraction)
        ! call add_cohort(destination,transfer_cohort)
        call combine_cohorts(transfer_cohort,destination%litterCohorts(nn),tempCohort)
        destination%litterCohorts(nn)=tempCohort
        source%litterCohorts(nn)=multiply_cohort(source%litterCohorts(nn),1.0-fraction)
    enddo

    destination%dissolved_carbon=destination%dissolved_carbon+source%dissolved_carbon*fraction
    source%dissolved_carbon=source%dissolved_carbon*(1.0-fraction)

end subroutine

!-------------------------------------------------------------------------------------------------------------------------------------
!Sums all litterCohorts in soil_carbon_pool (pool) into a single litterCohort

type(litterCohort) function totalCarbonCohort(pool)
    type(soil_carbon_pool),intent(in)::pool

    !Local Variables
    type(litterCohort)::tempCohort
    integer::ii

    call initializeCohort(totalCarbonCohort)

    IF(allocated(pool%litterCohorts)) THEN
    DO ii=1,size(pool%litterCohorts)
        call combine_cohorts(pool%litterCohorts(ii),totalCarbonCohort,tempCohort)
        totalCarbonCohort=tempCohort
    ENDDO
    ENDIF
end function

!-------------------------------------------------------------------------------------------------------------------------------------
subroutine poolTotalCarbon(pool,fastC,slowC,deadMicrobeC,liveMicrobeC,protectedC,&
        fast_dissolved,slow_dissolved,deadmic_dissolved,ncohorts,totalCarbon,&
        fast_protectedC,slow_protectedC,deadmic_protectedC)
    implicit none
    real, intent(out),optional::fastC,slowC,deadMicrobeC,liveMicrobeC,protectedC,totalCarbon,&
                                fast_dissolved,slow_dissolved,deadmic_dissolved,&
                                fast_protectedC,slow_protectedC,deadmic_protectedC
    integer, intent(out),optional::ncohorts
    type(soil_carbon_pool),intent(in)::pool

    type(litterCohort)::totalCohort
    integer::n

    totalCohort=totalCarbonCohort(pool)

    if (present(fastC)) fastC=totalCohort%litterC(LABILE)
    if (present(slowC)) slowC=totalCohort%litterC(RECALCTRNT)
    if (present(deadMicrobeC)) deadMicrobeC=totalCohort%litterC(DEADMICRB)
    if (present(liveMicrobeC)) liveMicrobeC=totalCohort%livingMicrobeC
    if (present(protectedC)) protectedC=sum(totalCohort%protectedC)
    if (present(fast_protectedC)) fast_protectedC=totalCohort%protectedC(LABILE)
    if (present(slow_protectedC)) slow_protectedC=totalCohort%protectedC(RECALCTRNT)
    if (present(deadmic_protectedC)) deadmic_protectedC=totalCohort%protectedC(DEADMICRB)

    if (present(fast_dissolved)) fast_dissolved=pool%dissolved_carbon(LABILE)
    if (present(slow_dissolved)) slow_dissolved=pool%dissolved_carbon(RECALCTRNT)
    if (present(deadmic_dissolved)) deadmic_dissolved=pool%dissolved_carbon(DEADMICRB)
    if (present(totalCarbon)) totalCarbon=sum(totalCohort%litterC)+sum(totalCohort%protectedC)+ &
            totalCohort%livingMicrobeC+sum(pool%dissolved_carbon)

    if (present(ncohorts)) then
        ncohorts=0
        do n=1,size(pool%litterCohorts)
            if (cohortCsum(pool%litterCohorts(n)).gt.0.0) ncohorts=ncohorts+1
        enddo
    endif
end subroutine poolTotalCarbon


!-------------------------------------------------------------------------------------------------------------------------------------
!Combine cohorts in a pool, making sure the total number is less than the pool max cohorts
subroutine cull_cohorts(pool)
    implicit none
    type(soil_carbon_pool),intent(inout)::pool

    !Local Variables
    integer::n,ncombined,m,c1,c2
    real::minDistance
    !real::Cbefore,Cafter
    real::Cafter
    type(litterCohort)::tempCohort

    n=1
    m=1
    ncombined=0

!    Cbefore=cohortCsum(totalCarbonCohort(pool))
!
!    DO WHILE(n.lt.size(pool%litterCohorts))
!        m=n+1
!        DO WHILE(m.le.size(pool%litterCohorts))
!            IF (canCombine(pool%litterCohorts(n),pool%litterCohorts(m))) THEN
!                call combine_cohorts(pool%litterCohorts(n),pool%litterCohorts(m),tempCohort)
!                call remove_cohort(pool,m)
!                pool%litterCohorts(n)=tempCohort
!                ncombined=ncombined+1
!            ENDIF
!            m=m+1
!        ENDDO
!        n=n+1
!    ENDDO !Cohort loop
!
!

    DO WHILE(size(pool%litterCohorts).GT.pool%max_cohorts)
        !Find closest pair of cohorts
        n=1
        m=2
        c1=n
        c2=m
        minDistance=cohortDistance(pool%litterCohorts(n),pool%litterCohorts(m))
        !print *,'Starting comp:',minDistance
        DO WHILE(n.lt.size(pool%litterCohorts))
        m=n+1

        DO WHILE(m.le.size(pool%litterCohorts))
            !print *,cohortDistance(pool%litterCohorts(n),pool%litterCohorts(m))
            IF (cohortDistance(pool%litterCohorts(n),pool%litterCohorts(m)).lt.minDistance) THEN
                minDistance=cohortDistance(pool%litterCohorts(n),pool%litterCohorts(m))
                c1=n
                c2=m
            ENDIF

            m=m+1
        ENDDO
        n=n+1
        ENDDO !Cohort loop
        call combine_cohorts(pool%litterCohorts(c1),pool%litterCohorts(c2),tempCohort)
        !PRINT '("At cohort ceiling (",I3,"): combined cohorts ",I3," and ",I3,",difference=",F8.3)',pool%max_Cohorts,c1,c2,minDistance
        pool%litterCohorts(c1)=tempCohort
        call remove_cohort(pool,c2)
        ncombined=ncombined+1
    ENDDO

    Cafter=cohortCsum(totalCarbonCohort(pool))
    !IF(ncombined.gt.0) WRITE (*,*),'Combined',ncombined,'cohorts'
    !totalCombineError=totalCombineError+(Cafter-Cbefore)

end subroutine


!-------------------------------------------------------------------------------------------------------------------------------------
!Calculate a numerical estimate of the difference between two cohorts,
!for deciding which are the closest and can be combined
real function cohortDistance(cohort1,cohort2)
    implicit none
    type(litterCohort)::cohort1,cohort2
    real::sum1,sum2

    !sum1=cohortCsum(cohort1,.TRUE.)
    !sum2=cohortCsum(cohort2,.TRUE.)
    sum1=sum(cohort1%litterC)
    sum2=sum(cohort2%litterC)

    IF (sum1.eq.0.0 .or. sum2.eq.0.0) THEN
        cohortDistance=0.0
    ELSE

        cohortDistance=sqrt(Cpoolcomp(cohort1%litterC(1),sum1,cohort2%litterC(1),sum2,.FALSE.)**2 &
                    + Cpoolcomp(cohort1%litterC(2),sum1,cohort2%litterC(2),sum2,.FALSE.)**2 &
                    + Cpoolcomp(cohort1%litterC(3),sum1,cohort2%litterC(3),sum2,.FALSE.)**2 &
                    !+ Cpoolcomp(sum(cohort1%protectedC),sum1,sum(cohort2%protectedC),sum2,.TRUE.)**2 &
                    !+ (Cpoolcomp(cohort1%livingMicrobeC,sum1,cohort2%livingMicrobeC,sum2,.FALSE.))**2 &
                    )

    ENDIF

end function


!-------------------------------------------------------------------------------------------------------------------------------------
!Calculate the difference between two cohort carbon pools.  Used to decide if the cohorts can be combined
real function Cpoolcomp(pool1,sum1,pool2,sum2,norm) result(compval)
    implicit none
    real, intent(in)::pool1,sum1,pool2,sum2
    logical,intent(in)::norm
    real::poolmean,pooldiff
    real::normval


    poolmean=0.5*(pool1/sum1+pool2/sum2)
    pooldiff=abs(pool1/sum1-pool2/sum2)

    IF (norm) THEN
        normval=poolmean
    ELSE
        normval=1.0
    ENDIF

    IF (poolmean.EQ.0.0) THEN
    compval=0.0
    ELSE
    compval=pooldiff/normval
    ENDIF
end function




!-------------------------------------------------------------------------------------------------------------------------------------
subroutine error_mesg(routine,message,level)
    implicit none
    character(len=*),intent(in)::routine,message
    integer::level

    if(level.eq.FATAL) then
    print *,'Error in routine ',routine,': ',message
    stop
    else
    print *,'Note from routine ',routine,': ',message
    endif
end subroutine


end module corpse_soil_carbon
